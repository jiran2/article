# 问题一

描述：介绍以下你使用过SpringCloud的哪几个组件，在你的项目中用处理了什么内容。（熔断怎么熔断；怎么负载均衡）

回答：

Eureka：注册中心，注册服务

Getway：网关，转发请求到服务上面

Ribbon：负载均衡

Feign：服务间调用

Hystrix：服务熔断



# 问题二

描述：你在什么场景使用过线程池，介绍下线程池的几个关键参数。



回答：

参数有七个

1. corePoolSize：核心线程数
2. maximumPoolSize 线程池最大线程数量
3. keepAliveTime 空闲线程存活时间
4. unit 空闲线程存活时间单位
5. workQueue 工作队列
6. threadFactory 线程工厂
7. handler 拒绝策略



# 问题三

描述：讲一下HashMap的实现以及他的hash算法。



回答：

HashMap实现

JDK7以前：数组+链表

JDK8以后：数组+链表+红黑树



# 问题四

描述：Spring支持几种bean的作用域？区别是什么？



回答：

常用的主要以下两种

- singleton：单例模式，在整个Spring IoC容器中，使用 singleton 定义的 bean 只有一个实例
- prototype：原型模式，每次通过容器的getbean方法获取 prototype 定义的 bean 时，都产生一个新的 bean 实例



# 问题五

描述：介绍下如何做MySQL的性能优化？



回答：

1、MySQL索引优化

2、MySQL主从分离

3、MySQL分库分表（MyCat或者sharding-jdbc）





# 问题六

描述：请介绍分布式锁的实现方法和他们的优缺点.

回答：

Redis实现分布式锁（Redisson）

使用的是Redis `setnx`命令



# 问题七

描述：缓存雪崩、缓存击穿、缓存穿透（原理及解决方案）



回答：

缓存雪崩：缓存穿透是指查询一个一定不存在的数据，导致Redis缓存失效，全部请求去查询数据库，导致数据库并发增加

解决方案：

1、有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

2、如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。



缓存击穿：缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

解决方案：在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。



缓存穿透：对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，但是失效了，导致请求全部访问数据库

解决方案：设置永远不过期



# 问题八

描述：JVM原理及调优

回答：

1、JVM内存结构

堆、方法区、程序计数器、栈、本地方法栈

2、垃圾回收算法

复制-清除

标记-清除 

标记-整理

3、垃圾收集器

Serial、Serial-Old（串行回收）

ParNew（并行回收）

Parallel-Scavenge、Parallel-Old（并发回收）

G1（目前主推）

ZGC（最新）

